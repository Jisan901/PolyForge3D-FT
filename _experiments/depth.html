<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Depth Texture</title>
</head>

<body style="margin:0; overflow:hidden">
    
    <script type="importmap">
        {
  "imports": {
    "three": "../node_modules/three/build/three.module.min.js",
    "three/webgpu": "../node_modules/three/build/three.webgpu.min.js",
    "three/tsl": "../node_modules/three/build/three.tsl.min.js",
    "three/addons/": "../node_modules/three/examples/jsm/"
  }
}
</script>
    
    <script type="module">
        import {threeWebgl, threeWebgpu, randMesh}  from './threeBase.js';
import { TransformControls } from 'three/addons/controls/TransformControls.js';



const {
        renderer,
        THREE,
        camera,
        controls,
        render
} = await threeWebgpu();

// ---------------- Scene ----------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);


camera.position.set(3, 3, 5);
camera.lookAt(0, 0, 0);

const material2 = new THREE.MeshStandardNodeMaterial({ color: 0x00ff00, transparent:true });

// ---------------- Mesh ----------------
//let mesh = new randMesh(2, 25, 84, THREE);


//scene.add(mesh)

//const m3 = new THREE.Mesh(
  //  new THREE.BoxGeometry(2, 2, 2),
//    material
 //   )
    //m3.renderOrder = 99
//scene.add(m3);



const intersectionGroup = new THREE.Group();
intersectionGroup.name = 'intersection-test-group';
scene.add(intersectionGroup);

// Floor
const floor = new THREE.Mesh(
  new THREE.BoxGeometry(10, 0.5, 10),
  new THREE.MeshStandardMaterial({ color: 0x808080 })
);
floor.position.set(0, -0.25, 0);
floor.userData.isCollider = true;
intersectionGroup.add(floor);

// Wall
const wall = new THREE.Mesh(
  new THREE.BoxGeometry(10, 3, 0.5),
  new THREE.MeshStandardMaterial({ color: 0x5555ff })
);
wall.position.set(0, 1.5, -5);
wall.userData.isCollider = true;
intersectionGroup.add(wall);


const sphereRadius = 2;

const sphere = new THREE.Mesh(
  new THREE.SphereGeometry(sphereRadius, 32, 32),
  material2
);
sphere.position.set(0, 1, 0);
scene.add(sphere);



const tfControl = new TransformControls(camera, renderer.domElement);
tfControl.attach(sphere);
scene.add(tfControl.getHelper());


tfControl.addEventListener('dragging-changed', (e) => {
  controls.enabled = !e.value;
});



scene.add(new THREE.DirectionalLight(0xffffff, 4));
scene.add(new THREE.AmbientLight(0x404040,1));


const textureLoader = new THREE.TextureLoader()

import { 
  uv, float, time, mul, vec2, add, texture, color, pow, dot, normalView, screenUV, viewportDepthTexture, cameraNear, cameraFar, perspectiveDepthToViewZ, positionView, sub, clamp, smoothstep, div, vec4, normalize,pass
} from 'three/tsl';
import { 
  MeshBasicNodeMaterial 
} from 'three/webgpu';
// TSL Graph Generation
const uv_1768243525457 = uv().mul(1);
const time_1768243541078 = time;
const mul_1768243854840 = time_1768243541078.mul(float(0.3));
const vec2_1768243983243 = vec2(float(0), mul_1768243854840);
const add_1768243535520 = uv_1768243525457.add(vec2_1768243983243);
const texture_1768243513281 = texture(textureLoader.load('https://raw.githubusercontent.com/Brackeys/Force-Field/refs/heads/master/Force%20Field/Assets/HexagonGrid.jpg'), add_1768243535520);
const color_1768243564108 = color('#00ff00');
const mul_1768243572523 = texture_1768243513281.mul(color_1768243564108);
const split_1768243808175 = mul_1768243572523;
const fresnel_fresnel = pow(float(1).sub(dot(normalView, normalize(positionView.negate()))), float(5));
const screenuv_scrUV = screenUV;
const viewportdepthtexture_depthTex = viewportDepthTexture(screenuv_scrUV);
const cameranear_camNear = cameraNear;
const camerafar_camFar = cameraFar;
const perspectivedepthtoviewz_sceneZ = perspectiveDepthToViewZ(viewportdepthtexture_depthTex, cameranear_camNear, camerafar_camFar);
const viewz_viewZ = positionView.z.mul(1).toVar();
const float_offset = float(0.3);
const sub_subOffset = viewz_viewZ.sub(float_offset);
const sub_diff = perspectivedepthtoviewz_sceneZ.sub(sub_subOffset);
const clamp_clamp = clamp(sub_diff, float(0), float(1));
const smoothstep_smooth = smoothstep(float(0), float(1), clamp_clamp);
const add_add = fresnel_fresnel.add(smoothstep_smooth);
const float_two = float(2);
const div_div = add_add.div(float_two);
const vec4_1768243736252 = vec4(split_1768243808175.x, split_1768243808175.y, split_1768243808175.z, div_div);
const material = new MeshBasicNodeMaterial();
material.fragmentNode = vec4_1768243736252;
material.opacityNode = float(1);
//material.positionNode = float(0);
material.transparent = true;
sphere.material = material 

const rawShader = await renderer.debug.getShaderAsync(scene, camera, sphere)
console.log(rawShader)


const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera ); // import {pass} from 'three/tsl'

postProcessing.outputNode = scenePass;


// ---------------- Render Loop ----------------
function animate() {
  requestAnimationFrame(animate);
    postProcessing.render()
}

animate();
    </script>
    
</body>

</html>